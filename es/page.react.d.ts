import React from 'react';
import { CommonAspectDict } from 'oak-common-aspect';
import { Aspect, CheckerType, EntityDict, OpRecord } from 'oak-domain/lib/types';
import { EntityDict as BaseEntityDict } from 'oak-domain/lib/base-app-domain';
import { BasicFeatures } from './features';
import { NamedFilterItem, NamedSorterItem } from './types/NamedCondition';
import { Feature } from './types/Feature';
import { DataOption, ComponentData, ComponentProps, OakComponentOption, OakNavigateToParameters } from './types/Page';
import { MessageProps } from './types/Message';
import { NotificationProps } from './types/Notification';
import { SyncContext } from 'oak-domain/lib/store/SyncRowStore';
import { AsyncContext } from 'oak-domain/lib/store/AsyncRowStore';
export declare function createComponent<IsList extends boolean, ED extends EntityDict & BaseEntityDict, T extends keyof ED, Cxt extends AsyncContext<ED>, FrontCxt extends SyncContext<ED>, AD extends Record<string, Aspect<ED, Cxt>>, FD extends Record<string, Feature>, FormedData extends Record<string, any>, TData extends Record<string, any> = {}, TProperty extends DataOption = {}, TMethod extends Record<string, Function> = {}>(option: OakComponentOption<IsList, ED, T, Cxt, FrontCxt, AD, FD, FormedData, TData, TProperty, TMethod>, features: BasicFeatures<ED, Cxt, FrontCxt, AD & CommonAspectDict<ED, Cxt>> & FD): {
    new (props: ComponentProps<ED, T, TProperty>): {
        features: BasicFeatures<ED, Cxt, FrontCxt, AD & CommonAspectDict<ED, Cxt>> & FD;
        oakOption: OakComponentOption<IsList, ED, T, Cxt, FrontCxt, AD, FD, FormedData, TData, TProperty, TMethod>;
        isReachBottom: boolean;
        methodProps: Record<string, Function>;
        defaultProperties: Record<string, any>;
        unmounted: boolean;
        iAmThePage(): string | undefined;
        isMobile(): boolean;
        supportPullDownRefresh(): boolean | "" | undefined;
        componentDidMount(): Promise<void>;
        componentWillUnmount(): void;
        componentDidUpdate(prevProps: Record<string, any>, prevState: Record<string, any>): Promise<void>;
        render(): React.ReactNode;
        featuresSubscribed: {
            name: string;
            callback: (args?: any) => void;
            unsubHandler?: (() => void) | undefined;
        }[];
        addFeatureSub(name: string, callback: (args?: any) => void): void;
        removeFeatureSub(name: string, callback: (args?: any) => void): void;
        unsubscribeAll(): void;
        subscribeAll(): void;
        subEvent(type: string, callback: Function): void;
        unsubEvent(type: string, callback: Function): void;
        pubEvent(type: string, options?: any): void;
        unsubAllEvents(type: string): void;
        save(key: string, item: any): Promise<void>;
        load(key: string): Promise<any>;
        clear(key?: string | undefined): Promise<void>;
        setNotification(data: NotificationProps): void;
        consumeNotification(): NotificationProps | undefined;
        setMessage(data: MessageProps): Promise<void>;
        consumeMessage(): MessageProps | undefined;
        reRender(extra?: Record<string, any> | undefined): void;
        navigateTo<T2 extends keyof ED>(options: {
            url: string;
        } & OakNavigateToParameters<ED, T2>, state?: Record<string, any> | undefined, disableNamespace?: boolean | undefined): Promise<void>;
        navigateBack(delta?: number | undefined): Promise<void>;
        redirectTo<T2_1 extends keyof ED>(options: {
            url: string;
        } & OakNavigateToParameters<ED, T2_1>, state?: Record<string, any> | undefined, disableNamespace?: boolean | undefined): Promise<void>;
        addItem<T extends keyof ED>(data: Omit<ED[T]["CreateSingle"]["data"], "id"> & {
            id?: string | undefined;
        }, path?: string | undefined): string;
        addItems<T_1 extends keyof ED>(data: (Omit<ED[T_1]["CreateSingle"]["data"], "id"> & {
            id?: string | undefined;
        })[], path?: string | undefined): string[];
        removeItem(id: string, path?: string | undefined): void;
        removeItems(ids: string[], path?: string | undefined): void;
        updateItem<T_2 extends keyof ED>(data: ED[T_2]["Update"]["data"], id: string, action?: ED[T_2]["Action"] | undefined, path?: string | undefined): void;
        recoverItem(id: string, path?: string | undefined): void;
        recoverItems(ids: string[], path?: string | undefined): void;
        resetItem(id: string, path?: string | undefined): void;
        update<T_3 extends keyof ED>(data: ED[T_3]["Update"]["data"], action?: ED[T_3]["Action"] | undefined, path?: string | undefined): void;
        create<T_4 extends keyof ED>(data: Omit<ED[T_4]["CreateSingle"]["data"], "id">, path?: string | undefined): void;
        remove(path?: string | undefined): void;
        isCreation(path?: string | undefined): boolean;
        clean(path?: string | undefined): void;
        t(key: string, params?: object | undefined): string;
        execute(action?: ED[T]["Action"] | undefined, messageProps?: boolean | MessageProps | undefined, path?: string | undefined, opers?: {
            entity: T;
            operation: ED[T]["Operation"];
        }[] | undefined): Promise<void>;
        isDirty(path?: string | undefined): boolean;
        getFreshValue(path?: string | undefined): Partial<ED[keyof ED]["Schema"]> | Partial<ED[keyof ED]["Schema"]>[] | undefined;
        checkOperation(entity: T, action: ED[T]["Action"], data?: ED[T]["Update"]["data"] | undefined, filter?: ED[T]["Update"]["filter"] | undefined, checkerTypes?: CheckerType[] | undefined): boolean;
        tryExecute(path?: string | undefined): boolean | Error;
        getOperations<T_5 extends keyof ED>(path?: string | undefined): {
            entity: keyof ED;
            operation: ED[keyof ED]["Operation"];
        }[] | undefined;
        refresh(): Promise<void>;
        loadMore(): Promise<void>;
        setId(id: string): void;
        unsetId(): void;
        getId(path?: string | undefined): string | undefined;
        setFilters(filters: NamedFilterItem<ED, T>[], path?: string | undefined): void;
        setNamedFilters(filters: NamedFilterItem<ED, T>[], refresh?: boolean | undefined, path?: string | undefined): void;
        getFilters(path?: string | undefined): any[] | undefined;
        getFilterByName(name: string, path?: string | undefined): any;
        addNamedFilter(namedFilter: NamedFilterItem<ED, T>, refresh?: boolean | undefined, path?: string | undefined): void;
        removeNamedFilter(namedFilter: NamedFilterItem<ED, T>, refresh?: boolean | undefined, path?: string | undefined): void;
        removeNamedFilterByName(name: string, refresh?: boolean | undefined, path?: string | undefined): void;
        setNamedSorters(namedSorters: NamedSorterItem<ED, T>[], refresh?: boolean | undefined, path?: string | undefined): void;
        getSorters(path?: string | undefined): ED[T]["Selection"]["sorter"][] | undefined;
        getSorterByName(name: string, path?: string | undefined): any;
        addNamedSorter(namedSorter: NamedSorterItem<ED, T>, refresh?: boolean | undefined, path?: string | undefined): void;
        removeNamedSorter(namedSorter: NamedSorterItem<ED, T>, refresh?: boolean | undefined, path?: string | undefined): void;
        removeNamedSorterByName(name: string, refresh?: boolean | undefined, path?: string | undefined): void;
        getPagination(path?: string | undefined): import(".").Pagination | undefined;
        setPageSize(pageSize: number, path?: string | undefined): void;
        setCurrentPage(currentPage: number, path?: string | undefined): void;
        subDataEvents(events: string[], callback: (event: string, opRecords: OpRecord<ED>[]) => void): Promise<void>;
        unsubDataEvents(events: string[]): Promise<void>;
        context: unknown;
        setState<K extends keyof TData | keyof FormedData | keyof import("./types/Page").OakComponentData<ED, T>>(state: ComponentData<ED, T, FormedData, TData> | ((prevState: Readonly<ComponentData<ED, T, FormedData, TData>>, props: Readonly<ComponentProps<ED, T, TProperty>>) => ComponentData<ED, T, FormedData, TData> | Pick<ComponentData<ED, T, FormedData, TData>, K> | null) | Pick<ComponentData<ED, T, FormedData, TData>, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<ComponentProps<ED, T, TProperty>>;
        state: Readonly<ComponentData<ED, T, FormedData, TData>>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<ComponentProps<ED, T, TProperty>>, nextState: Readonly<ComponentData<ED, T, FormedData, TData>>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<ComponentProps<ED, T, TProperty>>, prevState: Readonly<ComponentData<ED, T, FormedData, TData>>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<ComponentProps<ED, T, TProperty>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<ComponentProps<ED, T, TProperty>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<ComponentProps<ED, T, TProperty>>, nextState: Readonly<ComponentData<ED, T, FormedData, TData>>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<ComponentProps<ED, T, TProperty>>, nextState: Readonly<ComponentData<ED, T, FormedData, TData>>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
